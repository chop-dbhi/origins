// Code generated by protoc-gen-go.
// source: dal/protobuf.proto
// DO NOT EDIT!

/*
Package dal is a generated protocol buffer package.

It is generated from these files:
	dal/protobuf.proto

It has these top-level messages:
	ProtoTransaction
	ProtoLog
	ProtoSegment
	ProtoFact
*/
package dal

import proto "github.com/golang/protobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

// A transaction contains information about the state of the system when
// facts are being transacted.
type ProtoTransaction struct {
	ID               *uint64 `protobuf:"varint,1,req" json:"ID,omitempty"`
	StartTime        *int64  `protobuf:"varint,2,req" json:"StartTime,omitempty"`
	EndTime          *int64  `protobuf:"varint,3,req" json:"EndTime,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ProtoTransaction) Reset()         { *m = ProtoTransaction{} }
func (m *ProtoTransaction) String() string { return proto.CompactTextString(m) }
func (*ProtoTransaction) ProtoMessage()    {}

func (m *ProtoTransaction) GetID() uint64 {
	if m != nil && m.ID != nil {
		return *m.ID
	}
	return 0
}

func (m *ProtoTransaction) GetStartTime() int64 {
	if m != nil && m.StartTime != nil {
		return *m.StartTime
	}
	return 0
}

func (m *ProtoTransaction) GetEndTime() int64 {
	if m != nil && m.EndTime != nil {
		return *m.EndTime
	}
	return 0
}

// A log is the header of a linked list of segments. It is one of the few
// mutable values since it holds the pointer to the head of the linked list.
// Upon a successful transaction, the head is updated to point to the most
// segment.
type ProtoLog struct {
	Head             []byte `protobuf:"bytes,1,opt" json:"Head,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ProtoLog) Reset()         { *m = ProtoLog{} }
func (m *ProtoLog) String() string { return proto.CompactTextString(m) }
func (*ProtoLog) ProtoMessage()    {}

func (m *ProtoLog) GetHead() []byte {
	if m != nil {
		return m.Head
	}
	return nil
}

// A segment behaves as a node in a linked list in the scope of a domain. It
// corresponds to a transaction and maintains stats about contained facts.
// To access the facts, the segment key is combined with a block index, e.g
// segment.1.0 which translates to "segment 1 block 0".
type ProtoSegment struct {
	UUID             []byte  `protobuf:"bytes,1,req" json:"UUID,omitempty"`
	Transaction      *uint64 `protobuf:"varint,2,req" json:"Transaction,omitempty"`
	Time             *int64  `protobuf:"varint,3,req" json:"Time,omitempty"`
	Blocks           *int32  `protobuf:"varint,4,req" json:"Blocks,omitempty"`
	Count            *int32  `protobuf:"varint,5,req" json:"Count,omitempty"`
	Bytes            *int32  `protobuf:"varint,6,req" json:"Bytes,omitempty"`
	Next             []byte  `protobuf:"bytes,7,opt" json:"Next,omitempty"`
	Base             []byte  `protobuf:"bytes,8,opt" json:"Base,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ProtoSegment) Reset()         { *m = ProtoSegment{} }
func (m *ProtoSegment) String() string { return proto.CompactTextString(m) }
func (*ProtoSegment) ProtoMessage()    {}

func (m *ProtoSegment) GetUUID() []byte {
	if m != nil {
		return m.UUID
	}
	return nil
}

func (m *ProtoSegment) GetTransaction() uint64 {
	if m != nil && m.Transaction != nil {
		return *m.Transaction
	}
	return 0
}

func (m *ProtoSegment) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *ProtoSegment) GetBlocks() int32 {
	if m != nil && m.Blocks != nil {
		return *m.Blocks
	}
	return 0
}

func (m *ProtoSegment) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *ProtoSegment) GetBytes() int32 {
	if m != nil && m.Bytes != nil {
		return *m.Bytes
	}
	return 0
}

func (m *ProtoSegment) GetNext() []byte {
	if m != nil {
		return m.Next
	}
	return nil
}

func (m *ProtoSegment) GetBase() []byte {
	if m != nil {
		return m.Base
	}
	return nil
}

// Facts do not contain omit the domain and transaction ID since this info
// is contained in the tiers accessed above the fact. Specifically, the domain
// is required to access the fact, so it is attached to the fact when decoded.
// Likewise, the the transaction ID is referenced by the segment that is accessed
// prior to decoding facts. The fact operation is currently encoded as a boolean
// where true denotes "assert" and false denotes "retract".
type ProtoFact struct {
	Added            *bool   `protobuf:"varint,1,req" json:"Added,omitempty"`
	EntityDomain     *string `protobuf:"bytes,2,req" json:"EntityDomain,omitempty"`
	Entity           *string `protobuf:"bytes,3,req" json:"Entity,omitempty"`
	AttributeDomain  *string `protobuf:"bytes,4,req" json:"AttributeDomain,omitempty"`
	Attribute        *string `protobuf:"bytes,5,req" json:"Attribute,omitempty"`
	ValueDomain      *string `protobuf:"bytes,6,opt" json:"ValueDomain,omitempty"`
	Value            *string `protobuf:"bytes,7,req" json:"Value,omitempty"`
	Time             *int64  `protobuf:"varint,8,opt" json:"Time,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ProtoFact) Reset()         { *m = ProtoFact{} }
func (m *ProtoFact) String() string { return proto.CompactTextString(m) }
func (*ProtoFact) ProtoMessage()    {}

func (m *ProtoFact) GetAdded() bool {
	if m != nil && m.Added != nil {
		return *m.Added
	}
	return false
}

func (m *ProtoFact) GetEntityDomain() string {
	if m != nil && m.EntityDomain != nil {
		return *m.EntityDomain
	}
	return ""
}

func (m *ProtoFact) GetEntity() string {
	if m != nil && m.Entity != nil {
		return *m.Entity
	}
	return ""
}

func (m *ProtoFact) GetAttributeDomain() string {
	if m != nil && m.AttributeDomain != nil {
		return *m.AttributeDomain
	}
	return ""
}

func (m *ProtoFact) GetAttribute() string {
	if m != nil && m.Attribute != nil {
		return *m.Attribute
	}
	return ""
}

func (m *ProtoFact) GetValueDomain() string {
	if m != nil && m.ValueDomain != nil {
		return *m.ValueDomain
	}
	return ""
}

func (m *ProtoFact) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *ProtoFact) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func init() {
}
